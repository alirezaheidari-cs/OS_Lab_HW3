# OS_Lab_HW3

Alireza Heidari: 98109731
Hamidreza Yaghobi Araghi: 98109786


## 3.3.1

First we start our virtual linux:
![image](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/5524132e-6915-4e53-8b11-856a9c219102)

Then:
![VirtualBox_CE441_22_04_2024_16_41_37](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/3a7888ef-a6ba-4bfd-a767-6ac251e68300)

## 3.3.2

output of `/cat/proc/version/`

![VirtualBox_CE441_22_04_2024_16_45_16](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/93602f5e-3df3-4530-83a5-cfff819b51de)

output of `cat /proc/cpuinfo`

![cpuinfo](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/54050b9a-6549-4883-8884-01750dc38be8)

output of `cat /proc/meminfo`

![meminfo](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/5b35c3b4-a487-4d2d-be00-0ac7a882b697)

output of `cat /proc/devices`

![devices](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/a49341ab-f2e3-41dd-b5ea-ea17590085a5)

Following is our c++ program:

![image](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/a9d5b2b9-ec8a-48b8-8fd6-c760e0e74285)

After executing the script, we can find the content of the `Linux Version.txt` as follows:

![Screenshot from 2024-04-22 16-59-32](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/7365868e-687b-41ed-a11f-daff55366c20)

The `/proc` filesystem is a virtual filesystem that is provided by the Linux kernel. This filesystem is recreated after each boot and is mainly used to store kernel, process, and system information. Most of the files in this filesystem are not actual files but are instead pseudo-files that are generated dynamically when they are read or opened. The `/proc/version` file is also a read-only file that is dynamically generated by the kernel. Therefore, attempting to edit this file will not have any effect.

## 3.3.3

Following is the output of `ls /proc/1/`:

![Screenshot from 2024-04-22 17-29-47](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/5a3a8595-7431-40a8-aeb5-dc6ff72012a2)

- **`cmdline`**: This read-only file holds the  complete  command  line  for  the
process,  unless  the  process is a zombie.  In the latter case,
there is nothing in this file: that is, a read on this file will
return  0 characters.  The command-line arguments appear in this
file as a set of strings separated by null bytes ('\0'), with  a
further null byte after the last string.

If,  after  an execve(2), the process modifies its argv strings,
those changes will show up here.  This is not the same thing  as
modifying the argv array.

Furthermore,  a process may change the memory location that this
file refers via prctl(2) operations such as PR_SET_MM_ARG_START.

Think of this file as the command line that  the  process  wants
you to see.

![Screenshot from 2024-04-22 17-30-57](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/40f51e5d-6a59-43e2-b959-64265c1039d5)


- **`environ`**: This file contains the initial environment that was set when the
currently executing program was started via execve(2).  The  en‐
tries  are  separated  by  null bytes ('\0'), and there may be a
null byte at the end.  Thus, to print  out  the  environment  of
process 1, you would do:

$ cat /proc/1/environ | tr '\000' '\n'

If,  after  an  execve(2),  the process modifies its environment
(e.g., by calling functions such as putenv(3) or  modifying  the
environ(7)  variable directly), this file will not reflect those
changes.

Furthermore, a process may change the memory location that  this
file refers via prctl(2) operations such as PR_SET_MM_ENV_START.

Permission  to  access  this file is governed by a ptrace access
mode PTRACE_MODE_READ_FSCREDS check; see ptrace(2).

![Screenshot from 2024-04-22 17-31-34](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/dfb968d0-7299-4c99-ac2c-2d9f2327cb7d)


- **`stat`**: Status information about the process.  This is  used  by  ps(1).
It is defined in the kernel source file fs/proc/array.c.

The  fields,  in order, with their proper scanf(3) format speci‐
fiers, are listed below.  Whether or not certain of these fields
display  valid  information  is governed by a ptrace access mode
PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT check  (refer  to
ptrace(2)).  If the check denies access, then the field value is
displayed as 0.  The affected  fields  are  indicated  with  the
marking [PT].


![Screenshot from 2024-04-22 17-31-55](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/c6917423-1110-4954-8c82-b4351243b82c)

- `status`: Provides  much  of  the  information  in  /proc/[pid]/stat   and
/proc/[pid]/statm in a format that's easier for humans to parse.

![Screenshot from 2024-04-22 17-32-41](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/c8d73e40-b846-4566-8159-26a58aced454)
![Screenshot from 2024-04-22 17-32-53](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/ff8ec82e-db80-429a-ba54-2a7539dd6905)

- `statm`: Provides information about memory usage, measured in pages.  The
columns are:

size       (1) total program size
         (same as VmSize in /proc/[pid]/status)
resident   (2) resident set size
         (inaccurate; same as VmRSS in /proc/[pid]/status)
shared     (3) number of resident shared pages
         (i.e., backed by a file)
         (inaccurate; same as RssFile+RssShmem in
         /proc/[pid]/status)
text       (4) text (code)
lib        (5) library (unused since Linux 2.6; always 0)
data       (6) data + stack
dt         (7) dirty pages (unused since Linux 2.6; always 0)

Some of these values are inaccurate because of a kernel-internal
scalability optimization.  If accurate values are required,  use
/proc/[pid]/smaps or /proc/[pid]/smaps_rollup instead, which are
much slower but provide accurate, detailed information.

![Screenshot from 2024-04-22 17-33-47](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/132476c5-33ce-428b-80fd-0473bd431296)

- `cwd`: This  is a symbolic link to the current working directory of the
process.  To find out the current working directory  of  process
20, for instance, you can do this:

$ cd /proc/20/cwd; pwd -P

In  a  multithreaded process, the contents of this symbolic link
are not available if the  main  thread  has  already  terminated
(typically by calling pthread_exit(3)).

Permission  to  dereference  or read (readlink(2)) this symbolic
link is governed by a ptrace  access  mode  PTRACE_MODE_READ_FS‐
CREDS check; see ptrace(2).

![Screenshot from 2024-04-22 17-34-19](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/6abf7334-695c-44d9-81ce-f9219b3e80af)


- `exe`: Under Linux 2.2 and later, this file is a symbolic link contain‐
ing  the actual pathname of the executed command.  This symbolic
link can be dereferenced normally; attempting to  open  it  will
open  the  executable.  You can even type /proc/[pid]/exe to run
another copy of the same executable that is being run by process
[pid].   If  the  pathname  has been unlinked, the symbolic link
will contain the string '(deleted)'  appended  to  the  original
pathname.  In a multithreaded process, the contents of this sym‐
bolic link are not available if the main thread has already ter‐
minated (typically by calling pthread_exit(3)).

Permission  to  dereference  or read (readlink(2)) this symbolic
link is governed by a ptrace  access  mode  PTRACE_MODE_READ_FS‐
CREDS check; see ptrace(2).

Under Linux 2.0 and earlier, /proc/[pid]/exe is a pointer to the
binary which was executed, and appears as a  symbolic  link.   A
readlink(2)  call  on this file under Linux 2.0 returns a string
in the format:

[device]:inode

For example, [0301]:1502 would be inode 1502 on device major  03
(IDE,  MFM,  etc. drives) minor 01 (first partition on the first
drive).

find(1) with the -inum option can be used to locate the file.

![Screenshot from 2024-04-22 17-35-43](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/cc156ca6-69b5-46bf-acfe-89ea741222df)


- `root`: UNIX  and  Linux  support  the idea of a per-process root of the
filesystem, set by the chroot(2) system call.  This  file  is  a
symbolic  link  that points to the process's root directory, and
behaves in the same way as exe, and fd/*.

Note however that this file is not merely a symbolic  link.   It
provides  the  same view of the filesystem (including namespaces
and the set of per-process mounts) as the  process  itself.   An
example  illustrates  this  point.   In one terminal, we start a
shell in new user and mount namespaces, and  in  that  shell  we
create some new mount points:

$ PS1='sh1# ' unshare -Urnm
sh1# mount -t tmpfs tmpfs /etc  # Mount empty tmpfs at /etc
sh1# mount --bind /usr /dev     # Mount /usr at /dev
sh1# echo $$
27123

In  a second terminal window, in the initial mount namespace, we
look at the contents of the corresponding mounts in the  initial
and new namespaces:

$ PS1='sh2# ' sudo sh
sh2# ls /etc | wc -l                  # In initial NS
309
sh2# ls /proc/27123/root/etc | wc -l  # /etc in other NS
0                                     # The empty tmpfs dir
sh2# ls /dev | wc -l                  # In initial NS
205
sh2# ls /proc/27123/root/dev | wc -l  # /dev in other NS
11                                    # Actually bind
                                    # mounted to /usr
sh2# ls /usr | wc -l                  # /usr in initial NS
11

In a multithreaded process, the contents of the /proc/[pid]/root
symbolic link are not available if the main thread  has  already
terminated (typically by calling pthread_exit(3)).

Permission  to  dereference  or read (readlink(2)) this symbolic
link is governed by a ptrace  access  mode  PTRACE_MODE_READ_FS‐
CREDS check; see ptrace(2).



![Screenshot from 2024-04-22 17-36-17](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/e0e18287-2b96-46c6-a60d-16e70c5f8966)


Let's take a look at two directories inside the `/proc/1/root/`:

![Screenshot from 2024-04-22 17-36-56](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/22f7064e-0939-4e4b-b7b1-328997860267)
![Screenshot from 2024-04-22 17-37-54](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/c5091a9c-2d0b-4107-b8d6-eda669b02651)


Following is a bash code that displays all running processes:

![Screenshot from 2024-04-22 17-43-41](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/06a5d8ba-d7ef-4229-b68f-6da957d627b8)

Output:

![Screenshot from 2024-04-22 17-42-48](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/6b310d9b-c1ef-4bed-8ae9-623733529680)

**Excesize 3.1**

```
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <unistd.h>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <dirent.h>

using namespace std;

void printGeneralProcessInfo(string pid_str) {
    int pid = stoi(pid_str);

    string path = "/proc/" + to_string(pid) + "/";
    string cmdline, status;
    ifstream cmdFile(path + "cmdline");
    getline(cmdFile, cmdline);
    cmdFile.close();
    ifstream statusFile(path + "status");
    while (getline(statusFile, status)) {
        cout << status << endl;
    }
    statusFile.close();
    cout << "Command Line: " << cmdline << endl;
}

void printStatInfo(const std::string& path) {
    std::ifstream file(path + "/stat");
    std::string content;
    if (getline(file, content)) {
        std::istringstream iss(content);
        std::vector<std::string> stats;
        std::string token;
        while (iss >> token) {
            stats.push_back(token);
        }
        if (stats.size() > 22) {
            std::cout << "Process State: " << stats[2] << std::endl;
            std::cout << "User Time: " << stats[13] << std::endl;
            std::cout << "System Time: " << stats[14] << std::endl;
            std::cout << "Nice Value: " << stats[18] << std::endl;
            std::cout << "Number of Threads: " << stats[19] << std::endl;
            std::cout << "Start Time (relative to system boot): " << stats[21] << std::endl;
        }
    } else {
        std::cout << "Error reading stat file." << std::endl;
    }
    file.close();
}

void listOpenFiles(const std::string& path) {
    std::string fdPath = path + "/fd/";
    DIR* dir = opendir(fdPath.c_str());
    if (dir != nullptr) {
        struct dirent* entry;
        while ((entry = readdir(dir)) != nullptr) {
            if (entry->d_type == DT_LNK) {
                std::string fdLink = fdPath + entry->d_name;
                char target[1024];
                ssize_t len = readlink(fdLink.c_str(), target, sizeof(target) - 1);
                if (len != -1) {
                    target[len] = '\0';
                    std::cout << "Open file: " << target << std::endl;
                }
            }
        }
        closedir(dir);
    } else {
        std::cout << "Error opening fd directory." << std::endl;
    }
}

void printProcessInfo(const std::string& pid) {
    std::string path = "/proc/" + pid;
    std::ifstream file;

    char exeLink[1024] = {0};
    ssize_t len = readlink((path + "/exe").c_str(), exeLink, sizeof(exeLink) - 1);
    if (len != -1) {
        exeLink[len] = '\0';
        std::cout << "Executable Path: " << exeLink << std::endl;
    } else {
        std::cout << "Error reading link: " << strerror(errno) << std::endl;
    }

    file.open(path + "/statm");
    std::string mem;
    if (getline(file, mem)) {
        std::istringstream iss(mem);
        std::string total;
        iss >> total;
        int totalMemoryKb = std::stoi(total) * (sysconf(_SC_PAGESIZE) / 1024);
        std::cout << "Total Program Size: " << totalMemoryKb << " KB" << std::endl;
    } else {
        std::cout << "Error reading memory usage" << std::endl;
    }
    file.close();

    printStatInfo(path);

    file.open(path + "/environ");
    std::string env;
    std::cout << "Environment Variables:" << std::endl;
    bool isEmpty = true;
    while (getline(file, env, '\0')) {
        std::cout << env << std::endl;
        isEmpty = false;
    }
    if (isEmpty) {
        std::cout << "No environment variables found or error reading them." << std::endl;
    }
    file.close();
    listOpenFiles(path);
}

int main() {
    std::string pid;
    std::cout << "Enter Process ID: ";
    std::cin >> pid;
    printGeneralProcessInfo(pid);
    printProcessInfo(pid);
    return 0;
}
```

Output for ProcessId of 1 (systemd):

```
Enter Process ID: 1
Name:   systemd
Umask:  0000
State:  S (sleeping)
Tgid:   1
Ngid:   0
Pid:    1
PPid:   0
TracerPid:      0
Uid:    0       0       0       0
Gid:    0       0       0       0
FDSize: 512
Groups:  
NStgid: 1
NSpid:  1
NSpgid: 1
NSsid:  1
Kthread:        0
VmPeak:   234144 kB
VmSize:   168576 kB
VmLck:         0 kB
VmPin:         0 kB
VmHWM:     12880 kB
VmRSS:     12880 kB
RssAnon:            4864 kB
RssFile:            8016 kB
RssShmem:              0 kB
VmData:    21696 kB
VmStk:       132 kB
VmExe:       896 kB
VmLib:      9056 kB
VmPTE:        96 kB
VmSwap:        0 kB
HugetlbPages:          0 kB
CoreDumping:    0
THP_enabled:    1
untag_mask:     0xffffffffffffffff
Threads:        1
SigQ:   2/60616
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 7be3c0fe28014a03
SigIgn: 0000000000001000
SigCgt: 00000001000004ec
CapInh: 0000000000000000
CapPrm: 000001ffffffffff
CapEff: 000001ffffffffff
CapBnd: 000001ffffffffff
CapAmb: 0000000000000000
NoNewPrivs:     0
Seccomp:        0
Seccomp_filters:        0
Speculation_Store_Bypass:       thread vulnerable
SpeculationIndirectBranch:      conditional enabled
Cpus_allowed:   ffff
Cpus_allowed_list:      0-15
Mems_allowed:   00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000001
Mems_allowed_list:      0
voluntary_ctxt_switches:        8204
nonvoluntary_ctxt_switches:     611
Command Line: /sbin/initsplash
Error reading link: Permission denied
Total Program Size: 168576 KB
Process State: S
User Time: 82
System Time: 146
Nice Value: 0
Number of Threads: 1
Start Time (relative to system boot): 11
Environment Variables:
No environment variables found or error reading them.
Error opening fd directory.
```


Output (Partially) for ProcessId of 13490 (chrome):

```Open file: socket:[82005]
Open file: /home/alireza/.config/google-chrome/Safe Browsing/UrlSoceng.store.4_13358277740592617
Open file: socket:[115115]
Open file: /home/alireza/.config/google-chrome/Profile 1/IndexedDB/https_alirezaheidari.atlassian.net_0.indexeddb.leveldb/MANIFEST-000001
Open file: /home/alireza/.config/google-chrome/Profile 1/IndexedDB/https_alirezaheidari.atlassian.net_0.indexeddb.leveldb/001072.log
Open file: /home/alireza/.config/google-chrome/Profile 1/heavy_ad_intervention_opt_out.db
Open file: /home/alireza/.config/google-chrome/Profile 1/IndexedDB/https_alirezaheidari.atlassian.net_0.indexeddb.leveldb/001075.ldb
Open file: /home/alireza/.config/google-chrome/Profile 1/GCM Store/Encryption/LOCK
Open file: /home/alireza/.config/google-chrome/Profile 1/IndexedDB/https_alirezaheidari.atlassian.net_0.indexeddb.leveldb/001079.ldb
Open file: /home/alireza/.config/google-chrome/Safe Browsing/UrlMalware.store.4_13358277740892230
Open file: socket:[76512]
Open file: /home/alireza/.config/google-chrome/Profile 1/GCM Store/Encryption/MANIFEST-000001
Open file: /home/alireza/.config/google-chrome/Profile 1/IndexedDB/https_alirezaheidari.atlassian.net_0.indexeddb.leveldb/001076.ldb
Open file: /home/alireza/.config/google-chrome/Profile 1/File System/Origins/LOG
Open file: /home/alireza/.config/google-chrome/Profile 1/File System/Origins/LOCK
Open file: socket:[122215]
Open file: /home/alireza/.config/google-chrome/Profile 1/File System/Origins/MANIFEST-000001
Open file: /home/alireza/.config/google-chrome/Profile 1/File System/Origins/000003.log
Open file: socket:[122414]
Open file: /home/alireza/.config/google-chrome/Profile 1/IndexedDB/https_mail.google.com_0.indexeddb.leveldb/001497.ldb
Open file: /home/alireza/.config/google-chrome/Profile 1/GCM Store/LOCK
Open file: /home/alireza/.config/google-chrome/Safe Browsing/UrlUws.store.4_13358277740895195
Open file: /home/alireza/.config/google-chrome/CrashpadMetrics-active.pma
Open file: /home/alireza/.config/google-chrome/Profile 1/GCM Store/LOG
Open file: /home/alireza/.config/google-chrome/Profile 1/GCM Store/MANIFEST-000001
Open file: /home/alireza/.config/google-chrome/Safe Browsing/UrlBilling.store.4_13358277740897046
Open file: socket:[114364]
Open file: /home/alireza/.config/google-chrome/Profile 1/DIPS
Open file: /home/alireza/.config/google-chrome/Profile 1/GCM Store/000004.log
Open file: /home/alireza/.config/google-chrome/Profile 1/GCM Store/000005.ldb
Open file: /home/alireza/.config/google-chrome/optimization_guide_model_store/26/E6DC4029A1E4B4C1/AD05485274DF05D5/model.tflite
Open file: /home/alireza/.config/google-chrome/Profile 1/AggregationService
Open file: /home/alireza/.config/google-chrome/ZxcvbnData/3/ranked_dicts
Open file: /home/alireza/.config/google-chrome/Profile 1/Conversions
Open file: /home/alireza/.config/google-chrome/optimization_guide_model_store/24/E6DC4029A1E4B4C1/567D3D8A6C2421CD/model.tflite
Open file: /home/alireza/.config/google-chrome/Profile 1/Network Action Predictor
Open file: /home/alireza/.config/google-chrome/Profile 1/Shortcuts
Open file: /home/alireza/.config/google-chrome/Profile 1/DIPS-journal
Open file: /dev/shm/.com.google.Chrome.duAfRj (deleted)
Open file: /home/alireza/.config/google-chrome/optimization_guide_model_store/25/E6DC4029A1E4B4C1/41D135CABBD5B6AB/visual_model_desktop.tflite
Open file: /home/alireza/.config/google-chrome/Profile 1/Managed Extension Settings/kbfnbcaeplbcioakkpcpgfkobkghlhen/LOG
Open file: /home/alireza/.config/google-chrome/optimization_guide_model_store/34/E6DC4029A1E4B4C1/6D8DD33E20BBCA08/model.tflite
Open file: /home/alireza/.config/google-chrome/Profile 1/BrowsingTopicsSiteData
Open file: /home/alireza/.config/google-chrome/Profile 1/GCM Store/Encryption/LOG
Open file: socket:[110178]
Open file: /home/alireza/.config/google-chrome/Profile 1/Managed Extension Settings/kbfnbcaeplbcioakkpcpgfkobkghlhen/LOCK
Open file: /home/alireza/.config/google-chrome/Profile 1/GCM Store/Encryption/000003.log
Open file: /home/alireza/.config/google-chrome/Profile 1/Network Action Predictor-journal
Open file: /home/alireza/.config/google-chrome/Profile 1/Managed Extension Settings/kbfnbcaeplbcioakkpcpgfkobkghlhen/000003.log
Open file: /home/alireza/.config/google-chrome/optimization_guide_model_store/2/E6DC4029A1E4B4C1/288F43A16558D15B/model.tflite
Open file: /home/alireza/.config/google-chrome/Profile 1/Managed Extension Settings/kbfnbcaeplbcioakkpcpgfkobkghlhen/MANIFEST-000001
Open file: /home/alireza/.config/google-chrome/first_party_sets.db
Open file: /home/alireza/.config/google-chrome/Safe Browsing/UrlMalBin.store.4_13358277740897948
Open file: /home/alireza/.config/google-chrome/first_party_sets.db-journal
Open file: /home/alireza/.config/google-chrome/Safe Browsing/UrlSubresourceFilter.store.4_13358277740911866
Open file: socket:[130303]
Open file: /home/alireza/.config/google-chrome/Profile 1/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn/057130.log
Open file: /home/alireza/.config/google-chrome/Profile 1/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn/057131.ldb
Open file: socket:[86080]
Open file: socket:[124172]
Open file: socket:[90847]
Open file: socket:[130141]
Open file: /home/alireza/.config/google-chrome/Profile 1/Web Data-journal
Open file: socket:[121794]
Open file: socket:[128203]
Open file: socket:[91156]
Open file: /home/alireza/.config/google-chrome/Profile 1/Local Extension Settings/nkbihfbeogaeaoehlefnkodbefgpgknn/057127.ldb
Open file: socket:[121738]
Open file: /home/alireza/.config/google-chrome/Profile 1/Shortcuts-journal
Open file: socket:[121770]
Open file: socket:[77720]
Open file: /home/alireza/.config/google-chrome/Profile 1/SharedStorage-journal
Open file: socket:[121826]
Open file: socket:[115107]
Open file: socket:[102466]
Open file: socket:[76621]
Open file: /home/alireza/.config/google-chrome/Profile 1/Sessions/Tabs_13358277473420975
Open file: /home/alireza/.config/google-chrome/Profile 1/Login Data-journal
Open file: socket:[97439]
Open file: socket:[116534]
Open file: socket:[128425]
Open file: socket:[124197]
Open file: socket:[100325]
[1] + Done
```

## 3.3.4
**/proc/meminfo**

- **Purpose**: Provides detailed information about the system's memory usage, including total, free, available, used memory, and memory used for buffers and cache.
- **Contents**: Includes fields like MemTotal, MemFree, MemAvailable, Buffers, Cached, etc., which are crucial for understanding the memory performance and capacity.

**/proc/version**

- **Purpose**: Shows the version of the Linux kernel, the name of the compiler used to build the kernel, and the compiler version.
- **Contents**: Contains a single string that details the Linux kernel version, GCC version, and other build parameters.

**/proc/uptime**

- **Purpose**: Indicates how long the system has been on since it was last restarted.
- **Contents**: Contains two numbers: the first is the total number of seconds the system has been up, and the second is how much of that time the machine has spent idle.

**/proc/stat**

- **Purpose**: Provides system-wide statistics.
- **Contents**: Includes various pieces of information such as CPU usage times, boot time, number of processes created, and system interrupts.

**/proc/mounts**

- **Purpose**: Lists all the mounted filesystems currently used by the system.
- **Contents**: Similar to the classic mounts command output, showing device, mount point, filesystem type, and mount options.

**/proc/net**

- **Purpose**: Contains various network-related information and statistics.
- **Contents**: Includes files for different network protocols (e.g., netstat, dev, wireless), each providing specific data about the network operations.

**/proc/loadavg**

- **Purpose**: Shows the load average of the system.
- **Contents**: Contains five numbers representing the 1, 5, and 15 minute load averages (how many processes are in the queue or running), total number of runnable entities, and the largest PID used.

**/proc/interrupts**

- **Purpose**: Displays the number of interrupts per CPU per I/O device.
- **Contents**: Helps in diagnosing issues related to hardware interrupts and balancing between different CPUs.

**/proc/ioports**

- **Purpose**: Lists the range of I/O ports used by various devices connected to your computer.
- **Contents**: Shows which I/O ports are in use and which process is using them, which is useful for diagnosing conflicts and system resource management.

**/proc/filesystems**

- **Purpose**: Lists all the file systems supported by the kernel.
- **Contents**: Includes filesystem types that the kernel is configured to support, distinguishing between nodev (virtual filesystem) and device-backed filesystems.

**/proc/cpuinfo**

- **Purpose**: Provides detailed information about each CPU in the system.
- **Contents**: Includes data like processor number, core ID, CPU family, model, model name, stepping, MHz, cache size, and flags.

**/proc/cmdline**

- **Purpose**: Shows the parameters passed to the Linux kernel at the time of boot.
- **Contents**: A single string that lists all of the boot time parameters; useful for debugging and verifying system boot settings.

**First C++ Program**

```#include <iostream>
#include <fstream>
#include <string>
using namespace std;

int main() {
    ifstream cpuinfo("/proc/cpuinfo");
    string line;

    if (!cpuinfo.is_open()) {
        cerr << "Cannot open /proc/cpuinfo" << endl;
        return 1;
    }

    string model_name, cpu_MHz, cache_size;
    while (getline(cpuinfo, line)) {
        if (line.substr(0, 10) == "model name") {
            model_name = line.substr(line.find(':') + 2);
        }
        if (line.substr(0, 7) == "cpu MHz") {
            cpu_MHz = line.substr(line.find(':') + 2);
        }
        // Specific handling for cache size to ensure we capture it correctly
        size_t pos = line.find("cache size");
        if (pos != string::npos) {
            cache_size = line.substr(line.find(':') + 2);
        }
    }
    cpuinfo.close();

    cout << "Model Name: " << model_name << endl;
    cout << "CPU MHz: " << cpu_MHz << " MHz" << endl;
    cout << "Cache Size: " << cache_size << endl;

    return 0;
}
```

Output:

![image](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/74f2bf4a-f571-4b5c-8038-bc1db2a7da6b)


**Second C++ Program**

```#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
using namespace std;

int main() {
    ifstream meminfo("/proc/meminfo");
    string line;
    long totalMem = 0, freeMem = 0, availableMem = 0;

    if (!meminfo.is_open()) {
        cerr << "Cannot open /proc/meminfo" << endl;
        return 1;
    }

    while (getline(meminfo, line)) {
        if (line.substr(0, 9) == "MemTotal:") {
            istringstream(line.substr(line.find(':') + 1)) >> totalMem;
        }
        if (line.substr(0, 8) == "MemFree:") {
            istringstream(line.substr(line.find(':') + 1)) >> freeMem;
        }
        if (line.substr(0, 14) == "MemAvailable:") {
            istringstream(line.substr(line.find(':') + 1)) >> availableMem;
        }
    }
    meminfo.close();

    cout << "Total Memory: " << totalMem << " kB" << endl;
    cout << "Used Memory: " << (totalMem - availableMem) << " kB" << endl;
    cout << "Free Memory: " << freeMem << " kB" << endl;

    return 0;
}
```

Output:
![image](https://github.com/alirezaheidari-cs/OS_Lab_HW3/assets/59364943/c5505d7a-80a9-43f8-b275-26a2a3fbdb73)

**Exercise 3.2**

- **sched_latency_ns**: Determines the amount of time a task will run before the scheduler checks if it should be switched out.
- **sched_rt_period_us**: Defines the period size in microseconds for real-time scheduling.
- **msgmnb**: Maximum size in bytes of a message queue.
- **msgmax**: Maximum size in bytes of a single message in a message queue.
- **threads-max**: Maximum number of threads that can be created system-wide.

 **/proc/self**: It simply picks the currently-scheduled pid, i.e. the currently running process (on the current logical CPU). The effect is that `/proc/self` always points to the asking program's pid (`/proc/[current pid]`). In other words, `/proc/self` is a real symbolic link to the `/proc/` subdirectory of the process that is making the call.

